## Why this matters

Architects need to choose the right approach for tasks, especially when handling return values, exceptions, or integrating with thread pools.

## Key Concepts

Thread class: Extend Thread and override run() method.<br>
Pros: simple for standalone threads.<br>
Cons: Java doesn’t support multiple inheritance → can’t extend other classes.<br>
Runnable interface: Implement Runnable and pass to a Thread.<br>
Pros: Supports composition, thread pools.<br>
Cons: Cannot return a value or throw checked exceptions.<br>
Callable interface: Implement Callable<V> and submit to ExecutorService.\<br>
Pros: Returns value (Future<V>), can throw exceptions.<br>
Cons: Requires executor or FutureTask to run in a thread.<br>


## Using Thread Class

You can extend the Thread class and override its run() method.<br>
This is simple but less flexible because Java does not support multiple inheritance.<br>

Lifecycle:

new MyThread() → NEW<br>
start() → RUNNABLE → JVM schedules it → run() executes → TERMINATED<br>

## Using Runnable Interface

- Implement the Runnable interface and pass it to a Thread object.
- Preferred in most cases, especially when your class already extends another class.

```java
Runnable task = () -> System.out.println("Running Runnable task");
Thread t = new Thread(task);
t.start();
```

- Provides separation between task logic and thread management.

##  Using Callable Interface

- Introduced in Java 5 with the java.util.concurrent package.
- Like Runnable, but can return a value and throw checked exceptions.
- Typically used with ExecutorService.

```java
Callable<Integer> task = () -> {
    Thread.sleep(500);
    return 42;
};
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(task);
int result = future.get(); // blocks until callable completes
executor.shutdown();

```

## Diagram 
![Diagram](images/3.Runnable%20Callable%20and%20Thread.svg)

graph TD
ThreadCreation --> ThreadClass[Thread Class]
ThreadCreation --> RunnableInterface[Runnable Interface]
ThreadCreation --> CallableInterface[Callable Interface]

    RunnableInterface --> Thread[Runnable passed to Thread]
    CallableInterface --> FutureTask[Callable wrapped in FutureTask]
    FutureTask --> Executor[Submitted to ExecutorService]

## Key Differences:

| Feature              | Thread | Runnable | Callable       |
| -------------------- | ------ | -------- | -------------- |
| Return Value         | No     | No       | Yes            |
| Checked Exceptions   | No     | No       | Yes            |
| Usage                | Simple | Flexible | Executor-based |
| Functional Interface | No     | Yes      | Yes            |


## Architect Insights

- Prefer Runnable / Callable + ExecutorService for production systems (scalable, managed threads).
- Use Thread only for simple, ad-hoc tasks.
- Callable + Future allows handling results and exceptions cleanly.
- Avoid creating raw threads in high-load systems; prefer thread pools to reduce overhead.

## Example Code

```java
import java.util.concurrent.*;

public class ThreadCreationDemo {
    public static void main(String[] args) throws Exception {
        // Using Thread
        Thread t1 = new Thread(() -> System.out.println("Thread running"));
        t1.start();
        t1.join();

        // Using Runnable
        Runnable r = () -> System.out.println("Runnable running");
        Thread t2 = new Thread(r);
        t2.start();
        t2.join();

        // Using Callable
        Callable<String> c = () -> "Callable result";
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(c);
        System.out.println(future.get());
        executor.shutdown();
    }
}

```

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ThreadRunnableCallableDemo {
    public static void main(String[] args) throws InterruptedException, ExecutionException {

        //  Thread class
        Thread thread = new Thread() {
            public void run() {
                System.out.println("Thread class running");
            }
        };
        thread.start();
        thread.join();

        //  Runnable interface
        Runnable runnableTask = () -> System.out.println("Runnable running");
        Thread runnableThread = new Thread(runnableTask);
        runnableThread.start();
        runnableThread.join();

        // Callable interface with ExecutorService
        Callable<String> callableTask = () -> {
            Thread.sleep(500);
            return "Callable result";
        };
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(callableTask);
        System.out.println(future.get()); // "Callable result"
        executor.shutdown();
    }
}
```