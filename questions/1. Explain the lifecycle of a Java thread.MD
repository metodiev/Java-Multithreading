## 1. Thread Lifecycle States in Java

- Java threads go through six main states, represented by Thread.State:
- NEW → Thread is created but not yet started (new Thread(runnable)).
- RUNNABLE → Thread is ready to run, waiting for CPU scheduling.
- RUNNING → Thread is actively executing (a sub-state of RUNNABLE in practice).
- WAITING → Thread is waiting indefinitely for another thread’s signal (e.g., Object.wait() without timeout).
- TIMED_WAITING → Thread is waiting for a bounded time (e.g., sleep(ms), join(ms), wait(ms)).
- BLOCKED → Thread is waiting to acquire a monitor lock (synchronized block).
- TERMINATED → Thread has finished execution.


## 2. Transitions Between States

- NEW → RUNNABLE: call start().
- RUNNABLE ↔ RUNNING: controlled by thread scheduler.
- RUNNING → WAITING/TIMED_WAITING: calling wait(), join(), or sleep().
- RUNNING → BLOCKED: thread tries to enter a synchronized block but lock is held.
- WAITING/TIMED_WAITING/BLOCKED → RUNNABLE: lock acquired or signal/timeout.
- RUNNING → TERMINATED: run() method finishes.

## 3. Key Leadership/Architect Insight

- Performance impact: Too many threads in BLOCKED → lock contention.
- Deadlocks: Multiple threads permanently stuck in BLOCKED or WAITING.
- Scalability: Excessive threads stuck in TIMED_WAITING (due to poor thread pool config).
- Monitoring: Use jstack, VisualVM, or async profilers to inspect states.

## Diagram

![Diagram](images/1.lifecycle%20of%20a%20Java%20thread.svg)

## Code Example
```bash
stateDiagram-v2
    [*] --> NEW
    NEW --> RUNNABLE: start()
    RUNNABLE --> RUNNING: Scheduler
    RUNNING --> RUNNABLE: yield()/time slice
    RUNNING --> BLOCKED: lock contention
    BLOCKED --> RUNNABLE: lock acquired
    RUNNING --> WAITING: wait()
    RUNNING --> TIMED_WAITING: sleep()/join(timeout)/wait(timeout)
    WAITING --> RUNNABLE: notify()/notifyAll()
    TIMED_WAITING --> RUNNABLE: timeout/notify()
    RUNNING --> TERMINATED: run() ends
    TERMINATED --> [*]

```

```java
public class com.java.multithreading.interview.questions.ThreadLifecycleDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            try {
                Thread.sleep(1000); // TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println("State before start: " + t.getState()); // NEW
        t.start();
        Thread.sleep(100); // Let it start
        System.out.println("State after start: " + t.getState()); // RUNNABLE / TIMED_WAITING
        t.join(); // Waits for termination
        System.out.println("State after termination: " + t.getState()); // TERMINATED
    }
}

```

```java
public class ThreadStatesDemo {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();

        Thread holder = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(1500); // TIMED_WAITING
                } catch (InterruptedException ignored) {}
            }
        }, "Holder");

        Thread blocked = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Blocked thread acquired lock");
            }
        }, "Blocked");

        Thread sleeper = new Thread(() -> {
            try {
                Thread.sleep(2000); // TIMED_WAITING
            } catch (InterruptedException ignored) {}
        }, "Sleeper");

        // Show NEW state
        System.out.println("Initial state: " + holder.getState()); // NEW

        holder.start();
        Thread.sleep(50); // let holder acquire lock
        blocked.start();
        sleeper.start();

        Thread.sleep(100); // allow threads to settle
        System.out.println("Holder: " + holder.getState());   // TIMED_WAITING
        System.out.println("Blocked: " + blocked.getState()); // BLOCKED
        System.out.println("Sleeper: " + sleeper.getState()); // TIMED_WAITING

        holder.join();
        blocked.join();
        sleeper.join();

        System.out.println("Final Holder state: " + holder.getState()); // TERMINATED
    }
}
```

### Detailed Explanation of ThreadStatesDemo
```java

public class ThreadStatesDemo {
public static void main(String[] args) throws InterruptedException {
```

Entry point of the program. Throws InterruptedException allows main to call methods like Thread.sleep() and Thread.join() without handling the exception locally.

```java
        final Object lock = new Object();
```

- A simple monitor object (lock) is created.
- It will be used in synchronized blocks to demonstrate the BLOCKED state.

### Thread 1: holder

```java
 Thread holder = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(1500); // TIMED_WAITING
                } catch (InterruptedException ignored) {}
            }
        }, "Holder");
```

- Creates a thread named "Holder".

Behavior:
- Enters a synchronized block on lock (acquires the monitor).
- Calls Thread.sleep(1500) → the thread is TIMED_WAITING for 1.5 seconds.
- While it sleeps, it still holds the lock, so no other thread can enter the synchronized (lock) block.

### Thread 2: blocked

```java
        Thread blocked = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Blocked thread acquired lock");
            }
        }, "Blocked");

```


- Creates a thread named "Blocked".

Behavior:
- Tries to synchronized(lock) — but if holder is still holding it, "Blocked" cannot proceed.
- While waiting for the lock, its state becomes BLOCKED.
- Once "Holder" releases the lock, "Blocked" enters, prints "Blocked thread acquired lock", and exits.

### Thread 3: sleeper

```java
        Thread sleeper = new Thread(() -> {
            try {
                Thread.sleep(2000); // TIMED_WAITING
            } catch (InterruptedException ignored) {}
        }, "Sleeper");

```

Creates a thread named Sleeper.

Behavior:

- Immediately goes into Thread.sleep(2000) → state is TIMED_WAITING for 2 seconds.
- This thread does not interact with lock.

### Observing States

```java
        // Show NEW state
        System.out.println("Initial state: " + holder.getState()); // NEW

```

At this point, Holder has been created but not started.
- getState() prints NEW.

```java
        holder.start();
        Thread.sleep(50); // let holder acquire lock
        blocked.start();
        sleeper.start();

```


- Holder starts first, acquires the lock, and goes into TIMED_WAITING (sleeping).
- After a short pause (Thread.sleep(50)), we start "Blocked" and "Sleeper".

    - Blocked tries to acquire the same lock → it’s stuck → BLOCKED.
    - Sleeper starts → calls Thread.sleep(2000) → TIMED_WAITING.

```java
        Thread.sleep(100); // allow threads to settle
        System.out.println("Holder: " + holder.getState());   // TIMED_WAITING
        System.out.println("Blocked: " + blocked.getState()); // BLOCKED
        System.out.println("Sleeper: " + sleeper.getState()); // TIMED_WAITING

```


We pause briefly to let threads reach their target states.

Likely outcomes:

- Holder → TIMED_WAITING (still sleeping inside synchronized).
- Blocked → BLOCKED (waiting for "Holder" to release the lock).
- Sleeper → TIMED_WAITING (sleeping independently).

### Joining Threads

```java
        holder.join();
        blocked.join();
        sleeper.join();

```

- join() means the main thread waits until each of these threads finishes.
- Ensures program does not exit early.

### Final State

```java
System.out.println("Final Holder state: " + holder.getState()); // TERMINATED
```


- After finishing execution, each thread goes into TERMINATED state.
- Holder is explicitly checked, but Blocked and Sleeper are also terminated by then.