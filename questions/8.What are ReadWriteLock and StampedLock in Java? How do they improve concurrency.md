# Explanation

When multiple threads access shared data, read-heavy operations can benefit from allowing multiple readers while still protecting writes.

## Short Answer

- ReadWriteLock: allows multiple threads to read simultaneously while writes are exclusive. Improves concurrency in read-heavy scenarios.
- StampedLock: advanced lock introduced in Java 8; supports optimistic reads, read locks, and exclusive write locks. Optimistic reads are non-blocking, reducing contention.

Both locks improve throughput for scenarios where reads dominate writes.

## ReadWriteLock

- Separates read lock and write lock.
- Multiple readers can hold the read lock concurrently.
- Only one writer can hold the write lock at a time, blocking readers.
- Ideal for read-heavy data structures like caches, configuration maps.
- Interface in java.util.concurrent.locks.

#### Pros:

- High concurrency for reads.
- Simple API (ReentrantReadWriteLock).

#### Cons:
- Writers can starve if there are always readers (fairness mode mitigates this).
- Still uses blocking locks, so context switching can occur.

### StampedLock

Introduced in Java 8.

- Supports three modes:
  - Optimistic read: non-blocking read with a stamp; requires validation (validate(stamp)).
  - Read lock: shared lock, blocks writers.
  - Write lock: exclusive lock, blocks all readers and writers.

<br>

Optimistic reads avoid blocking unless a writer is active.

#### Pros:

- Very efficient for read-mostly workloads.
- Optimistic read reduces contention and improves throughput.

#### Cons:

- More complex API; requires careful stamp management.
- Optimistic reads may need retry if validation fails.

- Provides two locks:
  - Read lock — multiple threads can hold simultaneously.
  - Write lock — exclusive; only one thread can hold, and no readers are allowed.

<br>
Example: many threads reading a shared cache, occasional writes.

## Key Points:

| Lock Type         | Behavior                                                         |
| ----------------- | ---------------------------------------------------------------- |
| Read Lock         | Shared; multiple threads allowed simultaneously                  |
| Write Lock        | Exclusive; blocks readers and writers                            |
| Upgrade/Downgrade | Cannot upgrade read → write directly; can downgrade write → read |


```java
import java.util.concurrent.locks.*;

public class ReadWriteStampedLockDemo {
    private static int sharedData = 0;
    private static final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private static final StampedLock stampedLock = new StampedLock();

    public static void main(String[] args) throws InterruptedException {
        // Example with ReadWriteLock
        Thread reader1 = new Thread(() -> {
            rwLock.readLock().lock();
            try {
                System.out.println("Reader1 (ReadWriteLock) reads: " + sharedData);
                Thread.sleep(500);
            } catch (InterruptedException ignored) {}
            finally { rwLock.readLock().unlock(); }
        });

        Thread writer1 = new Thread(() -> {
            rwLock.writeLock().lock();
            try {
                sharedData++;
                System.out.println("Writer1 (ReadWriteLock) writes: " + sharedData);
                Thread.sleep(500);
            } catch (InterruptedException ignored) {}
            finally { rwLock.writeLock().unlock(); }
        });

        reader1.start();
        writer1.start();
        reader1.join();
        writer1.join();

        // Example with StampedLock
        Thread reader2 = new Thread(() -> {
            long stamp = stampedLock.tryOptimisticRead();
            int data = sharedData;
            try { Thread.sleep(200); } catch (InterruptedException ignored) {}
            if (!stampedLock.validate(stamp)) {
                stamp = stampedLock.readLock();
                try { data = sharedData; } finally { stampedLock.unlockRead(stamp); }
            }
            System.out.println("Reader2 (StampedLock) reads: " + data);
        });

        Thread writer2 = new Thread(() -> {
            long stamp = stampedLock.writeLock();
            try {
                sharedData++;
                System.out.println("Writer2 (StampedLock) writes: " + sharedData);
            } finally { stampedLock.unlockWrite(stamp); }
        });

        reader2.start();
        writer2.start();
        reader2.join();
        writer2.join();
    }
}

```

## Diagram

![Diagram](images/8.%20ReadWriteLock%20and%20StampedLock.svg)