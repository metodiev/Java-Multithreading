# Explanation

Java provides two primary mechanisms for thread synchronization:


## Intrinsic Locks (Monitors / synchronized)

- Built into every Java object.
- Acquired automatically when entering a synchronized method or block.
- Reentrant: a thread can acquire the same lock multiple times without deadlock.

Limited features:
  - Cannot check lock state.
  - Cannot interrupt a thread waiting for the lock.
  - Cannot attempt to acquire with timeout.

## Explicit Locks (ReentrantLock)

- Part of java.util.concurrent.locks.
- Provides more control than synchronized.
- Features:
  - Try to acquire lock: tryLock() returns immediately if lock not available.
  - Timeout support: tryLock(long timeout, TimeUnit unit).
  - Interruptible lock acquisition: lockInterruptibly().
  - Fairness policy: can enforce first-come-first-serve thread order.

### Fair vs Non-Fair Lock:
Non-fair (default): a thread requesting the lock can jump the queue, may get lock before waiting threads.
Fair: threads acquire the lock in the order they requested. Slightly lower throughput, but avoids starvation.

## Reentrancy
- Both synchronized and ReentrantLock are reentrant:
  - A thread holding a lock can acquire it again.
  - The lock keeps a count of acquisitions; it must be released the same number of times.

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {

    private final ReentrantLock lock = new ReentrantLock(true); // fair lock
    private int counter = 0;

    public void increment() {
        lock.lock();
        try {
            counter++;
            System.out.println(Thread.currentThread().getName() + " incremented to " + counter);
        } finally {
            lock.unlock(); // always unlock in finally
        }
    }

    public void decrement() {
        lock.lock();
        try {
            counter--;
            System.out.println(Thread.currentThread().getName() + " decremented to " + counter);
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReentrantLockDemo demo = new ReentrantLockDemo();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) demo.increment();
        }, "T1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) demo.decrement();
        }, "T2");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final counter: " + demo.counter);
    }
}

```

## Diagram

![Diagram](images/7.%20Reentrantlock.svg)