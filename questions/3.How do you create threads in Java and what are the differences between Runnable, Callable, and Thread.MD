## Why this matters

Architects need to choose the right approach for tasks, especially when handling return values, exceptions, or integrating with thread pools.

## Key Concepts

Thread class: Extend Thread and override run() method.
Pros: simple for standalone threads.
Cons: Java doesn’t support multiple inheritance → can’t extend other classes.
Runnable interface: Implement Runnable and pass to a Thread.
Pros: Supports composition, thread pools.
Cons: Cannot return a value or throw checked exceptions.
Callable interface: Implement Callable<V> and submit to ExecutorService.\
Pros: Returns value (Future<V>), can throw exceptions.
Cons: Requires executor or FutureTask to run in a thread.

## Diagram 
![Diagram](images/3.Runnable%20Callable%20and%20Thread.svg)

graph TD
ThreadCreation --> ThreadClass[Thread Class]
ThreadCreation --> RunnableInterface[Runnable Interface]
ThreadCreation --> CallableInterface[Callable Interface]

    RunnableInterface --> Thread[Runnable passed to Thread]
    CallableInterface --> FutureTask[Callable wrapped in FutureTask]
    FutureTask --> Executor[Submitted to ExecutorService]

## Architect Insights

- Prefer Runnable / Callable + ExecutorService for production systems (scalable, managed threads).
- Use Thread only for simple, ad-hoc tasks.
- Callable + Future allows handling results and exceptions cleanly.
- Avoid creating raw threads in high-load systems; prefer thread pools to reduce overhead.

## Example Code

```java
import java.util.concurrent.*;

public class ThreadCreationDemo {
    public static void main(String[] args) throws Exception {
        // Using Thread
        Thread t1 = new Thread(() -> System.out.println("Thread running"));
        t1.start();
        t1.join();

        // Using Runnable
        Runnable r = () -> System.out.println("Runnable running");
        Thread t2 = new Thread(r);
        t2.start();
        t2.join();

        // Using Callable
        Callable<String> c = () -> "Callable result";
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(c);
        System.out.println(future.get());
        executor.shutdown();
    }
}

```