# Explanation

The synchronized keyword in Java is used to control access to critical sections, ensuring that only one thread at a time can execute the synchronized code on the same object.

## Intrinsic Locks (Monitors)

- Every Java object has an intrinsic lock, also called a monitor.
- When a thread enters a synchronized block or method, it acquires the monitor of the specified object.
- Other threads trying to acquire the same monitor are blocked until the first thread releases it.

## Two Forms of synchronized

### Synchronized instance method

```java
synchronized void instanceMethod() { ... }

```
- Locks the object instance (this).

### Synchronized static method

```java
synchronized static void staticMethod() { ... }

```

- Locks the Class object (ClassName.class).
## Synchronized block

```java
synchronized(lockObject) {
    // critical section
}
```
- Locks the specific object passed as lockObject.
- More flexible and preferred for fine-grained locking.

## Monitor Internals (Simplified)


- JVM uses a monitor to manage the intrinsic lock:
    - Entry list — threads waiting to acquire the lock.
    - Wait set — threads that called wait() on the object and are waiting for notify().
    - Owner thread — the thread currently holding the lock.

- Reentrant: The same thread can enter a synchronized block multiple times without deadlocking itself.

### States for threads on a monitor:

- BLOCKED → waiting to acquire the lock.
- WAITING / TIMED_WAITING → waiting inside wait() or wait(timeout).

```java
public class SynchronizedDemo {

    private int counter = 0;

    // Synchronized instance method
    public synchronized void increment() {
        counter++;
        System.out.println(Thread.currentThread().getName() + " incremented counter to " + counter);
    }

    // Synchronized block with custom lock
    private final Object lock = new Object();
    public void decrement() {
        synchronized (lock) {
            counter--;
            System.out.println(Thread.currentThread().getName() + " decremented counter to " + counter);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SynchronizedDemo demo = new SynchronizedDemo();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) demo.increment();
        }, "T1");

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) demo.decrement();
        }, "T2");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final counter value: " + demo.counter);
    }
}

```

###  Explanation:

- increment() uses a synchronized method → locks demo object.
- decrement() uses a synchronized block → locks lock object.
- Threads cannot enter the same synchronized block/method simultaneously for the same object.
- counter updates are thread-safe because each critical section is protected by the respective lock.

### Non-Static Synchronized Methods

- Lock is acquired on the instance (this).
- Only one thread per object instance can execute synchronized methods at a time.
- Different instances have independent locks

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
        System.out.println(Thread.currentThread().getName() + " incremented to " + count);
    }

    public synchronized void decrement() {
        count--;
        System.out.println(Thread.currentThread().getName() + " decremented to " + count);
    }
}

public class NonStaticSyncDemo {
    public static void main(String[] args) throws InterruptedException {
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        Thread t1 = new Thread(() -> c1.increment(), "T1");
        Thread t2 = new Thread(() -> c1.decrement(), "T2");
        Thread t3 = new Thread(() -> c2.increment(), "T3");

        t1.start();
        t2.start();
        t3.start();

        t1.join();
        t2.join();
        t3.join();
    }
}

```

Behavior:
- t1 and t2 are synchronized on the same object (c1), so one waits for the other.
- t3 is synchronized on a different object (c2) — runs concurrently.

### Static Synchronized Methods

- Lock is acquired on the Class object.
- Only one thread per class can execute static synchronized methods at a time, regardless of instances.

```java
class StaticCounter {
    private static int count = 0;

    public static synchronized void increment() {
        count++;
        System.out.println(Thread.currentThread().getName() + " incremented to " + count);
    }

    public static synchronized void decrement() {
        count--;
        System.out.println(Thread.currentThread().getName() + " decremented to " + count);
    }
}

public class StaticSyncDemo {
    public static void main(String[] args) throws InterruptedException {
        StaticCounter c1 = new StaticCounter();
        StaticCounter c2 = new StaticCounter();

        Thread t1 = new Thread(() -> c1.increment(), "T1");
        Thread t2 = new Thread(() -> c2.decrement(), "T2");

        t1.start();
        t2.start();

        t1.join();
        t2.join();
    }
}

```

Behavior:

- t1 and t2 both lock StaticCounter.class, so only one thread runs at a time.
- Unlike non-static methods, multiple instances do not create independent locks.

### Key Takeaways

| Feature            | Non-Static Method    | Static Method                  |
| ------------------ | -------------------- | ------------------------------ |
| Lock Object        | this (instance)      | ClassName.class                |
| Lock Scope         | Per object instance  | Per class                      |
| Multiple Instances | Independent locks    | Shared lock across all instances |
| Use Case           | Protect instance state | Protect static/class state     |


## Diagram

![Diagram](images/6.%20Syncronized%20and%20locks.svg)


